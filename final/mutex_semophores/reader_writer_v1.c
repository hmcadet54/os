#include <stdio.h>     // Include the standard input/output library
#include <stdlib.h>    // Include the standard library for general functions
#include <time.h>      // Include the time library for generating random numbers
#include <semaphore.h> // Include the semaphore library
#include <pthread.h>   // Include the POSIX threads library
// Define the number of readers and writers
#define NUM_READERS 2
#define NUM_WRITERS 2

// Define the length of the string to be generated by the writers
#define STRING_LENGTH 20
// Declare the reader and writer threads
pthread_t readers[NUM_READERS], writers[NUM_WRITERS];
// Declare the mutex and read-write semaphores
sem_t mutex, rw_mutex;
// Declare the readers count
int readers_count = 0;
// Declare the file pointer
FILE *file;
// Function to generate a random lowercase character
char generateRandomChar()
{
    return (char)('a' + rand() % 26); // Generating a random lowercase character
}
// Reader thread function
void *reader(void *arg)
{
    // Infinite loop to keep reading from the file
    // while (1)
    // {
    // Wait for the mutex semaphore
    sem_wait(&mutex);
    // Increment the readers count
    readers_count++;
    // If this is the first reader, wait for the read-write semaphore
    if (readers_count == 1)
    {
        sem_wait(&rw_mutex);
    }
    // Release the mutex semaphore
    sem_post(&mutex);
    // Read from the file

    fseek(file, 0, SEEK_SET);                           // Move the file pointer to
    char buffer[256];                                   // Declare a buffer to
    while (fgets(buffer, sizeof(buffer), file) != NULL) // Read a line from the
    {
        fprintf(stdout, "Reader %ld: %s", (long)arg, buffer); // Print the read
    }
    // Wait for the mutex semaphore
    sem_wait(&mutex);
    // Decrement the readers count
    readers_count--;
    // If this is the last reader, release the read-write semaphore
    if (readers_count == 0)
    {
        sem_post(&rw_mutex);
    }
    // Release the mutex semaphore
    sem_post(&mutex);
    // Perform other tasks
    usleep(1000); // Sleep for 1 millisecond

    // }
}
void *writer(void *arg)
{
    // Writer thread function
    // while (1)
    // {
    // Wait for the read-write semaphore
    sem_wait(&rw_mutex);
    // Generate a random string to be written to the file
    srand(time(NULL));                    // Seed the random number generator
    char randomString[STRING_LENGTH + 1]; // Declare a buffer to store the random

    for (int i = 0; i < STRING_LENGTH; i++) // Generate a random string of
    {
        randomString[i] = generateRandomChar();
    }
    randomString[STRING_LENGTH] = '\0'; // Null-terminate the random string
    // Write the random string to the file
    fseek(file, 0, SEEK_END);            // Move the file pointer to the end of the
    fprintf(file, "%s\n", randomString); // Write the random string to the file
    fflush(file);                        // Flush the file buffer
    // Release the read-write semaphore
    sem_post(&rw_mutex);
    // Perform other tasks
    usleep(1000); // Sleep for 1 millisecond
    // }
}
// Main function
int main()
{
    // Open the shared file in append mode
    file = fopen("shared_file.txt", "a+");
    // Check if the file was opened successfully
    if (file == NULL)
    {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }
    // Initialize the mutex and read-write semaphores
    sem_init(&mutex, 0, 1);
    sem_init(&rw_mutex, 0, 1);
    // Create the reader and writer threads
    int i;
    for (i = 0; i < NUM_READERS; i++)
    {
        pthread_create(&readers[i], NULL, reader, (void *)i);
    }

    for (i = 0; i < NUM_WRITERS; i++)
    {
        pthread_create(&writers[i], NULL, writer, (void *)i);
    }
    // Join the reader and writer threads
    for (i = 0; i < NUM_READERS; i++)
    {
        pthread_join(readers[i], NULL);
    }
    for (i = 0; i < NUM_WRITERS; i++)
    {
        pthread_join(writers[i], NULL);
    }
    // Destroy the mutex and read-write semaphores
    sem_destroy(&mutex);
    sem_destroy(&rw_mutex);
    // Close the shared file
    fclose(file);
    return 0;
}